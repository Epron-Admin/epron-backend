"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var csv = require("fast-csv"),
    noop = require("noop6"),
    Streamp = require("streamp"),
    assured = require("assured"),
    fs = require("fs");

var CsvIt = function () {
    function CsvIt() {
        _classCallCheck(this, CsvIt);
    }

    _createClass(CsvIt, null, [{
        key: "read",


        /**
         * read
         * Read a CSV file.
         *
         * @name read
         * @function
         * @static
         * @param {String} file The file path of the CSV file.
         * @param {Object} opts An object containing the following fields:
         * @param {Function} cb The callback function.
         * @param {Function} onData The on data handler. If provided the rows will not be cached in memory.
         * @param {Function} transformFn The transform handler. Use it for async operations.
         * @returns {Promise} A promise resolving to the csv content.
         */
        value: function read(file) {
            var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
            var cb = arguments[2];
            var onData = arguments[3];
            var transformFn = arguments[4];


            // read(file, cb)
            if (typeof opts === "function") {
                onData = cb;
                cb = opts;
                opts = {};
            }

            cb = assured(cb || noop);

            opts = Object.assign({
                sep: ",",
                headers: true
            }, opts);

            var rows = [];
            var stream = fs.createReadStream(file);

            var onDataFn = onData ? onData : function (data) {
                rows.push(data);
            };

            var csvStream = csv.parse(opts);

            if (transformFn) {
                csvStream = csvStream.transform(transformFn);
            }

            csvStream = csvStream.on("data", onDataFn).on("error", cb).on("end", function () {
                cb(null, rows);
            });

            stream.pipe(csvStream);
            return cb._.then(function (res) {
                CsvIt.verbose && console.log("Parsed " + file + "...");
                return res;
            });
        }

        /**
         * write
         * Write the rows in the CSV file.
         *
         * @name write
         * @function
         * @static
         * @param {String} file The file path of the CSV file.
         * @param {Array} rows The rows to write in the CSV file.
         * @param {Object} opts An object containing the following fields:
         *
         *   - `headers` (Array|Boolean): The list of headers or enable the headers.
         *   - other fields passed to the `fast-csv` library
         *
         * @param {Function} cb The callback function.
         * @returns {Promise} A promise resolving to the csv content.
         */

    }, {
        key: "write",
        value: function write(file, rows) {
            var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
            var cb = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : noop;


            if (typeof opts === "function") {
                cb = opts;
                opts = {};
            }

            cb = assured(cb);
            var stream = CsvIt.writeAsync(file, opts, cb);
            rows.forEach(function (c) {
                return stream.write(c);
            });
            stream.end();
            return cb._;
        }

        /**
         * writeAsync
         * Create a CSV file stream which you can use to write rows manually.
         *
         * @name writeAsync
         * @function
         * @static
         * @param {String} file The file path of the CSV file.
         * @param {Array} rows The rows to write in the CSV file.
         * @param {Object} opts An object containing the following fields:
         *
         *     - `headers` (Array|Boolean): The list of headers or enable the headers.
         *     - `append` (Boolean): Wheater to append the data in the CSV file or override it (default: override)
         *     - other fields passed to the `fast-csv` library
         *
         * @param {Function} cb The callback function.
         * @returns {Stream} The CSV stream you can write to. Note you have to end it.
         */

    }, {
        key: "writeAsync",
        value: function writeAsync(file) {
            var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
            var cb = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : noop;


            if (typeof opts === "function") {
                cb = opts;
                opts = {};
            }

            var writableStream = new Streamp.writable({
                path: file,
                flags: opts.append ? "a" : "w"
            });

            opts = Object.assign({
                headers: true
            }, opts);

            var csvStream = csv.format(opts);

            csvStream.pipe(writableStream);
            writableStream.on("finish", function () {
                CsvIt.verbose && console.log("Written " + file);
                cb();
            });

            return csvStream;
        }
    }]);

    return CsvIt;
}();

CsvIt.verbose = true;

module.exports = CsvIt;